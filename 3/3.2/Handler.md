Необходимо объявить класс-декоратор с именем **Handler**, который можно было бы применять к функциям следующим образом:

```python
@Handler(methods=('GET', 'POST')) # по умолчанию methods = ('GET',)
def contact(request):
    return "Сергей Балакирев"
```

Здесь аргумент methods декоратора **Handler** содержит список разрешенных запросов для обработки. Сама декорированная функция вызывается по аналогии с предыдущим подвигом:

`res = contact({"method": "POST", "url": "contact.html"})`

В результате функция contact должна возвращать строку в формате:

_"<метод>: <данные из функции>"_

В нашем примере - это будет:

_"POST: Сергей Балакирев"_

Если ключ method в словаре request отсутствует, то по умолчанию подразумевается GET-запрос. Если ключ _method_ принимает значение отсутствующее в списке _methods_ декоратора **Handler**, например, _"PUT"_, то декорированная функция contact должна возвращать значение _None_.

Для имитации GET и POST-запросов в классе Handler необходимо объявить два вспомогательных метода с сигнатурами:

```python
def get(self, func, request, *args, **kwargs)  # - для имитации обработки GET-запроса
def post(self, func, request, *args, **kwargs)  # - для имитации обработки POST-запроса
```

В зависимости от типа запроса должен вызываться соответствующий метод (его выбор в классе можно реализовать методом ___getattribute__()_). На выходе эти методы должны формировать строки в заданном формате.

P.S. В программе достаточно объявить только класс. Ничего на экран выводить не нужно.
Небольшая справка

Для реализации декоратора с параметрами на уровне класса в инициализаторе `__init__(self, methods)` прописываем параметр для декоратора, а магический метод `__call__()` объявляем как полноценный декоратор на уровне функции, например:

```python
class Handler:
    def __init__(self, methods):
        # здесь нужные строчки

    def __call__(self, func):
        def wrapper(request, *args, **kwargs):
            # здесь нужные строчки
        return wrapper
```