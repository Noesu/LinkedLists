Ранее вы уже создавали классы валидации в виде иерархии базового класса **Validator** и дочерних:

**StringValidator**  
**IntegerValidator**  
**FloatValidator**

для валидации (проверки) корректности данных. Повторим этот функционал с некоторыми изменениями.

Итак, вначале нужно объявить базовый класс **Validator**, в котором должен отсутствовать инициализатор (магический метод `__init__`) и объявлен метод со следующей сигнатурой:
```python
def _is_valid(self, data): ...
```
По идее, этот метод возвращает булево значение _True_, если данные (_data_) корректны с точки зрения валидатора, и _False_ - в противном случае. Но в базовом классе **Validator** он должен генерировать исключение командой:
```python
raise NotImplementedError('в классе не переопределен метод _is_valid')
```
Затем, нужно объявить дочерний класс **FloatValidator** для валидации вещественных чисел. Объекты этого класса создаются командой:
```python
float_validator = FloatValidator(min_value, max_value)
```
где _min_value_ - минимально допустимое значение;  
_max_value_ - максимально допустимое значение.

Пользоваться объектами класса **FloatValidator** предполагается следующим образом:

`res = float_validator(value)`

где _value_ - проверяемое значение (должно быть вещественным и находиться в диапазоне _[min_value; max_value_]). Данный валидатор должен возвращать _True_, если значение value проходит проверку, и _False_ - в противном случае.

Пример использования классов (эти строчки писать не нужно):
```python
float_validator = FloatValidator(0, 10.5)
res_1 = float_validator(1)  # False (целое число, а не вещественное)
res_2 = float_validator(1.0)  # True
res_3 = float_validator(-1.0)  # False (выход за диапазон [0; 10.5])
```
P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.