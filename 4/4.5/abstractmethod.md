(про модуль _abc_). 
В языке Python есть еще один распространенный способ объявления абстрактных методов класса через декоратор _abstractmethod_ модуля _abc_:
```python
from abc import ABC, abstractmethod
```
Чтобы корректно работал декоратор _abstractmethod_ сам класс должен наследоваться от базового класса _ABC_. Например, так:
```python
class Transport(ABC):
    @abstractmethod
    def go(self):
        """Метод для перемещения транспортного средства"""

    @classmethod
    @abstractmethod
    def abstract_class_method(cls):
        """Абстрактный метод класса"""
```
Мы здесь имеем два абстрактных метода внутри класса **Transport**, причем, первый метод `go()` - это обычный метод, а второй `abstract_class_method()` - это абстрактный метод уровня класса. Обратите внимание на порядок использования декораторов _classmethod_ и _abstractmethod_. Они должны быть записаны именно в такой последовательности.

Теперь, если объявить какой-либо дочерний класс, например:
```python
class Bus(Transport):
    def __init__(self, model, speed):
        self._model = model
        self._speed = speed

    def go(self):
        print("bus go")

    @classmethod
    def abstract_class_method(cls):
        pass
```
То в нем обязательно нужно переопределить абстрактные методы `go` и `abstract_class_method` класса **Transport**. Иначе, объект класса **Bus** не будет создан (возникнет исключение TypeError).

Используя эту информацию, объявите базовый класс **Model** (модель), в котором нужно объявить один абстрактный метод с сигнатурой:

`def get_pk(self): ...`

и один обычный метод:

`def get_info(self): ...`

который бы возвращал строку `"Базовый класс Model"`.

На основе класса **Model** объявите дочерний класс **ModelForm**, объекты которого создаются командой:
```python
form = ModelForm(login, password)
```
где _login_ - заголовок перед полем ввода логина (строка);  
_password_ - заголовок перед полем ввода пароля (строка).  
В каждом объекте класса **ModelForm** должны формироваться локальные атрибуты с именами __login_ и __password_, а также автоматически появляться локальный атрибут __id_ с уникальным целочисленным значением для каждого объекта класса **ModelForm**.

В классе **ModelForm** переопределите метод:

`def get_pk(self): ...`

который должен возвращать значение атрибута __id_.

Пример использования классов (эти строчки в программе писать не нужно):
```python
form = ModelForm("Логин", "Пароль")
print(form.get_pk())
```
P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.